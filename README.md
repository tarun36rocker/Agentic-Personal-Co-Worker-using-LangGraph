# Agentic Personal Co-Worker using LangGraph

## Overview

This repository contains an **agentic personal co-worker system** built using **LangGraph**, designed to iteratively assist users in completing tasks using tools, reasoning loops, and structured evaluation.

The system is explicitly **agentic by design**, consisting of a worker agent that actively executes tasks, an evaluator agent that verifies progress against success criteria, and a tools layer that enables real-world interaction such as web browsing, search, file operations, and code execution.

Rather than responding once and stopping, the Sidekick operates as a persistent collaborator that continues working until the success criteria are met or additional user input is required.

---

## Key Features

* **LangGraph-based agentic control flow**
* **Explicit success-criteria driven task completion**
* **Tool-augmented reasoning and execution**
* **Evaluator feedback loop for self-correction**
* **Interactive Gradio chat interface**
* **Persistent conversational memory per session**

---

## Tech Stack

* **Python**
* **LangGraph**
* **LangChain**
* **OpenAI Chat Models**
* **Playwright** for browser automation
* **Gradio** for the interactive UI
* **Pydantic** for structured evaluator outputs

---

## How It Works

The system is implemented as an **iterative agentic loop** driven by a graph-based state machine.

At a high level, the workflow is:

1. User submits a task and success criteria via the UI
2. The worker agent attempts to complete the task using reasoning and tools
3. If tools are required, control is routed to the tools node
4. The evaluator agent assesses whether the success criteria are met
5. If not met, feedback is provided and control returns to the worker
6. The loop continues until success criteria are satisfied or clarification is required

This design enables autonomous retries, self-improvement, and transparent reasoning.

---

## Code Architecture

### 1. User Interface (`app.py`)

This file defines the **Gradio-based chat interface** for interacting with the Sidekick.

Key responsibilities:

* Captures user requests and success criteria
* Streams conversation history and evaluator feedback
* Manages Sidekick lifecycle and cleanup
* Provides reset and session control

The UI is intentionally designed to remain responsive during long-running agentic interactions.

---

### 2. Sidekick Agent (`sidekick.py`)

The `Sidekick` class is the **core agentic engine**.

It:

* Defines the LangGraph state and transitions
* Configures the worker and evaluator agents
* Routes execution between worker, tools, and evaluator
* Maintains per-session memory using checkpoints
* Orchestrates the full reasoning loop

This file encodes the agentic behaviour and decision-making logic.

---

### 3. Tools Layer (`sidekick_tools.py`)

This module defines all external tools available to the Sidekick, including:

* Browser automation via Playwright
* Web search using Serper
* Wikipedia queries
* Python REPL execution
* File management tools
* Push notifications

These tools allow the agent to act beyond text generation and interact with real systems.

---

## Agent Graph Explanation

The Sidekick is powered by a **LangGraph state machine**, illustrated below.

![Agent Graph](res/work.png)

### Graph Breakdown

* **START**  
  Entry point of the workflow.

* **Worker**  
  The primary agent responsible for progressing the task. It reasons, asks clarifying questions, or invokes tools as needed.

* **Tools**  
  Executes external actions such as browsing, searching, file operations, or running Python code.

* **Evaluator**  
  Assesses the worker’s output against the provided success criteria and returns structured feedback.

* **END**  
  The workflow terminates when the task is completed successfully or when further user input is required.

Conditional routing ensures the system can loop intelligently until the task reaches a satisfactory conclusion.

---

## Live Interaction and Feedback Loop

A core design goal of this project is **continuous transparency**.

During execution, users can observe:

* Tool usage decisions
* Intermediate reasoning steps
* Evaluator feedback on failures
* Clear explanations when clarification is needed

This makes the Sidekick feel like an active collaborator rather than a one-shot assistant.

---

## Example Output

Below is an example of a completed interaction generated by the Sidekick.

![Result Example](res/1.png)

This demonstrates the system’s ability to iteratively refine its output until the success criteria are met.
